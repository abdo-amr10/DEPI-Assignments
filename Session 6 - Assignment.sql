USE STOREDB;

-- 1. customer spending analysis
DECLARE @CUSTOMERID INT = 1;
DECLARE @TOTALSPENT DECIMAL(10,2);

SELECT @TOTALSPENT = SUM(OI.QUANTITY * OI.LIST_PRICE * (1 - OI.DISCOUNT))
FROM SALES.ORDERS O, SALES.ORDER_ITEMS OI
WHERE O.ORDER_ID = OI.ORDER_ID
AND O.CUSTOMER_ID = @CUSTOMERID;

SELECT 
    @CUSTOMERID AS CUSTOMERID,
    @TOTALSPENT AS TOTALSPENT,
    CASE 
        WHEN @TOTALSPENT > 5000 THEN 'VIP CUSTOMER'
        ELSE 'REGULAR CUSTOMER'
    END AS CUSTOMERSTATUS;
GO

-- 2. product price threshold report
DECLARE @PRICETHRESHOLD DECIMAL(10,2) = 1500;
DECLARE @PRODUCTCOUNT INT;

SELECT @PRODUCTCOUNT = COUNT(*) 
FROM PRODUCTION.PRODUCTS
WHERE LIST_PRICE > @PRICETHRESHOLD;

SELECT CONCAT('THERE ARE ', @PRODUCTCOUNT,' PRODUCTS PRICED ABOVE $', @PRICETHRESHOLD) AS REPORTMESSAGE;
GO

-- 3. staff performance calculator
DECLARE @STAFFID INT = 2;
DECLARE @YEAR INT = 2017;
DECLARE @TOTALSALES DECIMAL(10,2);

SELECT @TOTALSALES = SUM(OI.QUANTITY * OI.LIST_PRICE * (1 - OI.DISCOUNT))
FROM SALES.ORDERS O, SALES.ORDER_ITEMS OI
WHERE O.ORDER_ID = OI.ORDER_ID
AND O.STAFF_ID = @STAFFID 
AND YEAR(O.ORDER_DATE) = @YEAR;

SELECT 
    @STAFFID AS STAFFID,
    @YEAR AS YEAR,
    @TOTALSALES AS TOTALSALES,
    CONCAT('STAFF #', @STAFFID, ' ACHIEVED $', FORMAT(@TOTALSALES, 'N2'), ' IN SALES DURING ', @YEAR) AS PERFORMANCESUMMARY;
GO

-- 4. global variables information
SELECT 
    @@SERVERNAME AS SERVERNAME,
    @@VERSION AS SQLSERVERVERSION,
    @@ROWCOUNT AS ROWSAFFECTED;
GO

-- 5. inventory level check
DECLARE @PRODUCTID INT = 1;
DECLARE @STOREID INT = 1;
DECLARE @QUANTITY INT;

SELECT @QUANTITY = QUANTITY 
FROM PRODUCTION.STOCKS 
WHERE PRODUCT_ID = @PRODUCTID AND STORE_ID = @STOREID;

IF @QUANTITY > 20
    SELECT 'WELL STOCKED' AS INVENTORYSTATUS;
ELSE IF @QUANTITY BETWEEN 10 AND 20
    SELECT 'MODERATE STOCK' AS INVENTORYSTATUS;
ELSE IF @QUANTITY < 10
    SELECT 'LOW STOCK - REORDER NEEDED' AS INVENTORYSTATUS;
ELSE
    SELECT 'NO STOCK DATA AVAILABLE' AS INVENTORYSTATUS;
GO

-- 6. while loop low-stock update
DECLARE @BATCHSIZE INT = 3;
DECLARE @ROWSAFFECTED INT = 1;

WHILE @ROWSAFFECTED > 0
BEGIN
    UPDATE TOP (@BATCHSIZE) PRODUCTION.STOCKS
    SET QUANTITY = QUANTITY + 10
    WHERE QUANTITY < 5;
    
    SET @ROWSAFFECTED = @@ROWCOUNT;
    
    IF @ROWSAFFECTED > 0
        PRINT CONCAT('UPDATED ', @ROWSAFFECTED, ' LOW-STOCK ITEMS');
END;
PRINT 'ALL LOW-STOCK ITEMS UPDATED';
GO

-- 7. product price categorization
SELECT 
    PRODUCT_ID,
    PRODUCT_NAME,
    LIST_PRICE,
    CASE 
        WHEN LIST_PRICE < 300 THEN 'BUDGET'
        WHEN LIST_PRICE BETWEEN 300 AND 800 THEN 'MID-RANGE'
        WHEN LIST_PRICE BETWEEN 801 AND 2000 THEN 'PREMIUM'
        ELSE 'LUXURY'
    END AS PRICECATEGORY
FROM PRODUCTION.PRODUCTS
ORDER BY LIST_PRICE DESC;
GO

-- 8. customer order validation
DECLARE @CUSTOMERID INT = 5;

IF EXISTS (SELECT 1 FROM SALES.CUSTOMERS WHERE CUSTOMER_ID = @CUSTOMERID)
    SELECT COUNT(*) AS ORDERCOUNT 
    FROM SALES.ORDERS 
    WHERE CUSTOMER_ID = @CUSTOMERID;
ELSE
    SELECT 'CUSTOMER NOT FOUND' AS MESSAGE;
GO

-- 9. shipping cost calculator function
CREATE FUNCTION CALCULATESHIPPING(@ORDERTOTAL DECIMAL(10,2))
RETURNS DECIMAL(10,2)
AS
BEGIN
    RETURN CASE 
        WHEN @ORDERTOTAL > 100 THEN 0
        WHEN @ORDERTOTAL BETWEEN 50 AND 99 THEN 5.99
        ELSE 12.99
    END;
END;
GO

-- 10. product category function
CREATE FUNCTION GETPRODUCTSBYPRICERANGE(@MINPRICE DECIMAL(10,2), @MAXPRICE DECIMAL(10,2))
RETURNS TABLE
AS
RETURN
    SELECT 
        P.PRODUCT_ID,
        P.PRODUCT_NAME,
        P.LIST_PRICE,
        B.BRAND_NAME,
        C.CATEGORY_NAME
    FROM PRODUCTION.PRODUCTS P, PRODUCTION.BRANDS B, PRODUCTION.CATEGORIES C
    WHERE P.BRAND_ID = B.BRAND_ID
    AND P.CATEGORY_ID = C.CATEGORY_ID
    AND P.LIST_PRICE BETWEEN @MINPRICE AND @MAXPRICE;
GO

-- 11. customer sales summary function
CREATE FUNCTION GETCUSTOMERYEARLYSUMMARY(@CUSTOMERID INT)
RETURNS @SUMMARY TABLE (
    YEAR INT,
    ORDERCOUNT INT,
    TOTALSPENT DECIMAL(10,2),
    AVGORDERVALUE DECIMAL(10,2)
)
AS
BEGIN
    INSERT INTO @SUMMARY
    SELECT 
        YEAR(ORDER_DATE) AS YEAR,
        COUNT(DISTINCT O.ORDER_ID) AS ORDERCOUNT,
        SUM(OI.QUANTITY * OI.LIST_PRICE * (1 - OI.DISCOUNT)) AS TOTALSPENT,
        AVG(OI.QUANTITY * OI.LIST_PRICE * (1 - OI.DISCOUNT)) AS AVGORDERVALUE
    FROM SALES.ORDERS O, SALES.ORDER_ITEMS OI
    WHERE O.ORDER_ID = OI.ORDER_ID
    AND O.CUSTOMER_ID = @CUSTOMERID
    GROUP BY YEAR(ORDER_DATE);
    RETURN;
END;
GO

-- 12. discount calculation function
CREATE FUNCTION CALCULATEBULKDISCOUNT(@QUANTITY INT)
RETURNS DECIMAL(10,2)
AS
BEGIN
    RETURN CASE 
        WHEN @QUANTITY BETWEEN 1 AND 2 THEN 0
        WHEN @QUANTITY BETWEEN 3 AND 5 THEN 5
        WHEN @QUANTITY BETWEEN 6 AND 9 THEN 10
        ELSE 15
    END;
END;
GO

-- 13. customer order history procedure
CREATE PROCEDURE SP_GETCUSTOMERORDERHISTORY
    @CUSTOMERID INT,
    @STARTDATE DATE = NULL,
    @ENDDATE DATE = NULL
AS
BEGIN
    SELECT 
        O.ORDER_ID,
        O.ORDER_DATE,
        SUM(OI.QUANTITY * OI.LIST_PRICE * (1 - OI.DISCOUNT)) AS ORDERTOTAL
    FROM SALES.ORDERS O, SALES.ORDER_ITEMS OI
    WHERE O.ORDER_ID = OI.ORDER_ID
    AND O.CUSTOMER_ID = @CUSTOMERID
    AND (@STARTDATE IS NULL OR O.ORDER_DATE >= @STARTDATE)
    AND (@ENDDATE IS NULL OR O.ORDER_DATE <= @ENDDATE)
    GROUP BY O.ORDER_ID, O.ORDER_DATE
    ORDER BY O.ORDER_DATE DESC;
END;
GO

-- 14. inventory restock procedure
CREATE PROCEDURE SP_RESTOCKPRODUCT
    @STOREID INT,
    @PRODUCTID INT,
    @RESTOCKQTY INT,
    @OLDQTY INT OUTPUT,
    @NEWQTY INT OUTPUT,
    @SUCCESS BIT OUTPUT
AS
BEGIN
    SELECT @OLDQTY = QUANTITY 
    FROM PRODUCTION.STOCKS 
    WHERE STORE_ID = @STOREID AND PRODUCT_ID = @PRODUCTID;
    
    IF @OLDQTY IS NULL
    BEGIN
        SET @SUCCESS = 0;
        RETURN;
    END;
    
    UPDATE PRODUCTION.STOCKS
    SET QUANTITY = QUANTITY + @RESTOCKQTY
    WHERE STORE_ID = @STOREID AND PRODUCT_ID = @PRODUCTID;
    
    SET @NEWQTY = @OLDQTY + @RESTOCKQTY;
    SET @SUCCESS = 1;
END;
GO

GO

-- 16. dynamic product search procedure
CREATE PROCEDURE SP_SEARCHPRODUCTS
    @SEARCHTERM VARCHAR(255) = NULL,
    @CATEGORYID INT = NULL,
    @MINPRICE DECIMAL(10,2) = NULL,
    @MAXPRICE DECIMAL(10,2) = NULL,
    @SORTCOLUMN VARCHAR(255) = 'PRODUCT_NAME'
AS
BEGIN
    DECLARE @SQL NVARCHAR(MAX);
    
    SET @SQL = N'
    SELECT 
        P.PRODUCT_ID,
        P.PRODUCT_NAME,
        P.LIST_PRICE,
        B.BRAND_NAME,
        C.CATEGORY_NAME
    FROM PRODUCTION.PRODUCTS P, PRODUCTION.BRANDS B, PRODUCTION.CATEGORIES C
    WHERE P.BRAND_ID = B.BRAND_ID
    AND P.CATEGORY_ID = C.CATEGORY_ID';
    
    IF @SEARCHTERM IS NOT NULL
        SET @SQL = @SQL + N' AND P.PRODUCT_NAME LIKE ''%' + @SEARCHTERM + '%''';
    
    IF @CATEGORYID IS NOT NULL
        SET @SQL = @SQL + N' AND P.CATEGORY_ID = ' + CAST(@CATEGORYID AS VARCHAR);
    
    IF @MINPRICE IS NOT NULL
        SET @SQL = @SQL + N' AND P.LIST_PRICE >= ' + CAST(@MINPRICE AS VARCHAR);
    
    IF @MAXPRICE IS NOT NULL
        SET @SQL = @SQL + N' AND P.LIST_PRICE <= ' + CAST(@MAXPRICE AS VARCHAR);
    
    SET @SQL = @SQL + N' ORDER BY ' + @SORTCOLUMN;
    
    EXEC SP_EXECUTESQL @SQL;
END;
GO

-- 17. staff bonus calculation system
DECLARE @STARTDATE DATE = '2023-01-01';
DECLARE @ENDDATE DATE = '2023-03-31';
DECLARE @BASERATE DECIMAL(5,2) = 0.05;

SELECT 
    S.STAFF_ID,
    S.FIRST_NAME + ' ' + S.LAST_NAME AS STAFF_NAME,
    SUM(OI.QUANTITY * OI.LIST_PRICE * (1 - OI.DISCOUNT)) AS TOTAL_SALES,
    CASE 
        WHEN SUM(OI.QUANTITY * OI.LIST_PRICE * (1 - OI.DISCOUNT)) > 50000 THEN @BASERATE + 0.03
        WHEN SUM(OI.QUANTITY * OI.LIST_PRICE * (1 - OI.DISCOUNT)) > 20000 THEN @BASERATE + 0.02 
        ELSE @BASERATE 
    END AS BONUS_RATE,
    SUM(OI.QUANTITY * OI.LIST_PRICE * (1 - OI.DISCOUNT)) * 
    CASE 
        WHEN SUM(OI.QUANTITY * OI.LIST_PRICE * (1 - OI.DISCOUNT)) > 50000 THEN @BASERATE + 0.03
        WHEN SUM(OI.QUANTITY * OI.LIST_PRICE * (1 - OI.DISCOUNT)) > 20000 THEN @BASERATE + 0.02
        ELSE @BASERATE
    END AS BONUS_AMOUNT
FROM SALES.ORDERS O, SALES.ORDER_ITEMS OI, SALES.STAFFS S
WHERE O.ORDER_ID = OI.ORDER_ID
AND O.STAFF_ID = S.STAFF_ID
AND O.ORDER_DATE BETWEEN @STARTDATE AND @ENDDATE
GROUP BY S.STAFF_ID, S.FIRST_NAME, S.LAST_NAME
ORDER BY BONUS_AMOUNT DESC;
GO

-- 18. smart inventory management
UPDATE S
SET S.QUANTITY = 
    CASE 
        WHEN C.CATEGORY_NAME = 'PREMIUM' AND S.QUANTITY < 10 THEN S.QUANTITY + 20
        WHEN C.CATEGORY_NAME = 'STANDARD' AND S.QUANTITY < 5 THEN S.QUANTITY + 15
        ELSE S.QUANTITY + 10
    END
FROM PRODUCTION.STOCKS S, PRODUCTION.PRODUCTS P, PRODUCTION.CATEGORIES C
WHERE S.PRODUCT_ID = P.PRODUCT_ID
AND P.CATEGORY_ID = C.CATEGORY_ID
AND S.QUANTITY < 10;
GO

-- 19. customer loyalty tier assignment
SELECT 
    C.CUSTOMER_ID,
    C.FIRST_NAME + ' ' + C.LAST_NAME AS CUSTOMER_NAME,
    COALESCE(SUM(OI.QUANTITY * OI.LIST_PRICE * (1 - OI.DISCOUNT)), 0) AS TOTAL_SPENT,
    CASE 
        WHEN SUM(OI.QUANTITY * OI.LIST_PRICE * (1 - OI.DISCOUNT)) IS NULL THEN 'NO ORDERS'
        WHEN SUM(OI.QUANTITY * OI.LIST_PRICE * (1 - OI.DISCOUNT)) > 5000 THEN 'PLATINUM'
        WHEN SUM(OI.QUANTITY * OI.LIST_PRICE * (1 - OI.DISCOUNT)) > 2000 THEN 'GOLD'
        WHEN SUM(OI.QUANTITY * OI.LIST_PRICE * (1 - OI.DISCOUNT)) > 500 THEN 'SILVER'
        ELSE 'STANDARD'
    END AS LOYALTY_TIER
FROM SALES.CUSTOMERS C
LEFT JOIN SALES.ORDERS O ON C.CUSTOMER_ID = O.CUSTOMER_ID
LEFT JOIN SALES.ORDER_ITEMS OI ON O.ORDER_ID = OI.ORDER_ID
GROUP BY C.CUSTOMER_ID, C.FIRST_NAME, C.LAST_NAME
ORDER BY TOTAL_SPENT DESC;
GO
